<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>VoltDodge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Rajdhani', sans-serif;
            background-color: #0c0a1a;
            color: #ffffff;
            overflow: hidden;
            touch-action: none; /* Prevents scrolling on mobile */
        }
        .neon-text {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #00aaff, 0 0 20px #00aaff, 0 0 25px #00aaff, 0 0 30px #00aaff, 0 0 35px #00aaff;
        }
        .neon-button {
            border: 2px solid #00aaff;
            box-shadow: 0 0 5px #00aaff, 0 0 10px #00aaff, 0 0 15px #00aaff inset;
            transition: all 0.2s ease-in-out;
        }
        .neon-button:hover, .neon-button.active {
            background-color: #00aaff;
            color: #0c0a1a;
            box-shadow: 0 0 10px #00aaff, 0 0 20px #00aaff, 0 0 30px #fff;
        }
         .neon-button:disabled {
            border-color: #444;
            color: #666;
            cursor: not-allowed;
            box-shadow: none;
        }
        canvas {
            background-color: #0c0a1a; /* Fallback */
            display: block;
            margin: auto;
            cursor: pointer;
        }
        .powerup-icon {
            width: 32px;
            height: 32px;
        }
        .skin-card {
            border: 2px solid #3a2fb0;
            transition: all 0.2s ease-in-out;
        }
        .skin-card.selected {
            border-color: #00aaff;
            box-shadow: 0 0 10px #00aaff;
        }
        .skin-card.locked {
            background-color: rgba(0,0,0,0.5);
        }
    </style>
</head>
<body class="w-full h-screen flex items-center justify-center">

    <div id="game-container" class="relative w-full h-full max-w-md mx-auto flex items-center justify-center">
        <canvas id="gameCanvas"></canvas>

        <!-- UI Elements -->
        <div id="ui-layer" class="absolute inset-0 flex flex-col items-center justify-between p-4 text-white pointer-events-none">
            <div class="w-full flex justify-between items-start">
                 <div>
                    <h1 class="text-3xl font-bold neon-text">VoltDodge</h1>
                    <div id="high-score-container" class="text-lg font-bold text-left">HI <span id="high-score">0</span></div>
                 </div>
                 <div class="flex flex-col items-end">
                    <div id="score-container" class="text-4xl font-bold text-right hidden">
                        <span id="score">0</span>
                    </div>
                    <div id="powerup-status" class="flex space-x-2 mt-2"></div>
                 </div>
            </div>
        </div>
        
        <!-- Game Over / Start Menu -->
        <div id="menu" class="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center">
            <div id="start-menu" class="text-center">
                <h2 class="text-6xl font-bold neon-text mb-4">VoltDodge</h2>
                <p class="text-xl mb-8">Swipe to survive the surge.</p>
                <button id="start-button" class="neon-button text-2xl font-bold py-3 px-8 rounded-lg uppercase tracking-widest">Start</button>
                <button id="skins-button" class="mt-4 neon-button text-xl font-bold py-2 px-6 rounded-lg uppercase tracking-widest">Skins</button>
            </div>
            <div id="game-over-menu" class="text-center hidden">
                <h2 class="text-5xl font-bold neon-text mb-2">Game Over</h2>
                <p class="text-2xl mb-1">Final Score</p>
                <p id="final-score" class="text-7xl font-bold mb-4">0</p>
                <p id="taunt-message" class="text-amber-400 text-lg mb-4 hidden max-w-xs mx-auto"></p>
                <div class="flex flex-col items-center">
                    <button id="retry-button" class="w-48 neon-button text-2xl font-bold py-3 px-8 rounded-lg uppercase tracking-widest">Retry</button>
                    <button id="skins-button-gameover" class="w-48 mt-4 neon-button text-xl font-bold py-2 px-6 rounded-lg uppercase tracking-widest">Skins</button>
                </div>
            </div>
             <div id="skins-menu" class="w-full h-full p-4 text-center hidden flex-col">
                <h2 class="text-4xl font-bold neon-text mb-2">Select Skin</h2>
                <p class="text-lg mb-4">Total Distance: <span id="total-distance">0</span></p>
                <div id="skins-grid" class="flex-grow grid grid-cols-2 gap-4 overflow-y-auto">
                    <!-- Skins will be populated here -->
                </div>
                <div class="mt-4 flex justify-center">
                    <button id="back-button" class="neon-button text-xl font-bold py-2 px-6 rounded-lg uppercase tracking-widest">Back</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- UI Elements ---
        const scoreEl = document.getElementById('score');
        const finalScoreEl = document.getElementById('final-score');
        const scoreContainer = document.getElementById('score-container');
        const highScoreEl = document.getElementById('high-score');
        const menu = document.getElementById('menu');
        const startMenu = document.getElementById('start-menu');
        const gameOverMenu = document.getElementById('game-over-menu');
        const skinsMenu = document.getElementById('skins-menu');
        const startButton = document.getElementById('start-button');
        const retryButton = document.getElementById('retry-button');
        const skinsButton = document.getElementById('skins-button');
        const skinsButtonGameOver = document.getElementById('skins-button-gameover');
        const backButton = document.getElementById('back-button');
        const skinsGrid = document.getElementById('skins-grid');
        const totalDistanceEl = document.getElementById('total-distance');
        const powerupStatusEl = document.getElementById('powerup-status');
        const tauntMessageEl = document.getElementById('taunt-message');

        let TILE_SIZE, GRID_WIDTH, GRID_HEIGHT, PLAYER_SIZE, PULSE_HEIGHT;

        // --- Skin Definitions ---
        const SKINS = [
            { id: 'default', name: 'Default', unlockScore: 0, color: '#00ffff', shape: 'circle', symbol: '‚óè' },
            { id: 'ember', name: 'Ember', unlockScore: 5000, color: '#ff4500', shape: 'circle', symbol: '‚óè' },
            { id: 'jade', name: 'Jade', unlockScore: 15000, color: '#00ff7f', shape: 'square', symbol: '‚ñ†' },
            { id: 'void', name: 'Void', unlockScore: 30000, color: '#9400d3', shape: 'triangle', symbol: '‚ñ≤' },
            { id: 'gold', name: 'Gold', unlockScore: 50000, color: '#ffd700', shape: 'square', symbol: '‚ñ†' }
        ];

        // --- Game State ---
        let gameState = 'menu';
        let player, path, pulses = [], powerups = [], score, gameSpeed, frameCount;
        let particles = [], stars = [];
        let screenShakeIntensity = 0;
        let highScore = 0;
        let totalDistance = 0;
        let previousScore = 0;
        let currentSkinId = 'default';
        let menuToReturnTo = 'start';

        // Power-up state
        let shieldActive = false;
        let scoreBoostActive = false;
        let scoreBoostTimer = 0;
        const POWERUP_DURATION = 300; // 5 seconds at 60fps

        // --- Player Controls ---
        let touchStartX = 0;
        let touchEndX = 0;

        // --- Initial Setup ---
        function setCanvasDimensions() {
            const container = document.getElementById('game-container');
            const aspectRatio = 9 / 16;
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            canvas.height = containerHeight;
            canvas.width = containerHeight * aspectRatio;
            if (canvas.width > containerWidth) {
                canvas.width = containerWidth;
                canvas.height = containerWidth / aspectRatio;
            }

            TILE_SIZE = canvas.width / 9;
            GRID_WIDTH = 7;
            GRID_HEIGHT = Math.ceil(canvas.height / TILE_SIZE);
            PLAYER_SIZE = TILE_SIZE * 0.4;
            PULSE_HEIGHT = TILE_SIZE * 0.3;
        }

        // --- Game Objects ---
        class Player {
            constructor() {
                this.lane = Math.floor(GRID_WIDTH / 2);
                this.y = canvas.height - TILE_SIZE * 3;
                this.targetX = (this.lane + 1.5) * TILE_SIZE;
                this.currentX = this.targetX;
                this.pulse = 0;
                this.skin = SKINS.find(s => s.id === currentSkinId);
            }

            draw() {
                const size = PLAYER_SIZE + Math.sin(this.pulse) * 2;
                ctx.save();
                ctx.fillStyle = this.skin.color;
                ctx.shadowColor = this.skin.color;
                ctx.shadowBlur = 20;
                ctx.beginPath();

                if (this.skin.shape === 'square') {
                     ctx.fillRect(this.currentX - size, this.y - size, size * 2, size * 2);
                } else if (this.skin.shape === 'triangle') {
                    ctx.moveTo(this.currentX, this.y - size);
                    ctx.lineTo(this.currentX - size, this.y + size);
                    ctx.lineTo(this.currentX + size, this.y + size);
                    ctx.closePath();
                } else { // Default to circle
                    ctx.arc(this.currentX, this.y, size, 0, Math.PI * 2);
                }
                
                ctx.fill();
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                 if (this.skin.shape !== 'triangle') { // Inner highlight
                    ctx.arc(this.currentX, this.y, size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                 }
                ctx.restore();

                if (shieldActive) {
                    ctx.save();
                    ctx.strokeStyle = '#00aaff';
                    ctx.lineWidth = 5;
                    ctx.shadowColor = '#00aaff';
                    ctx.shadowBlur = 15;
                    ctx.globalAlpha = 0.6 + Math.sin(this.pulse * 2) * 0.3;
                    ctx.beginPath();
                    ctx.arc(this.currentX, this.y, size * 1.5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            }
            
            update() {
                this.pulse += 0.1;
                this.currentX += (this.targetX - this.currentX) * 0.3;
                if (gameState === 'playing' && frameCount % 2 === 0) {
                     particles.push(new Particle(this.currentX, this.y, 2, this.skin.color, {x: (Math.random() - 0.5) * 0.5, y: Math.random() * 1 + 1}, 20));
                }
            }

            move(direction) {
                const newLane = this.lane + direction;
                if (newLane >= 0 && newLane < GRID_WIDTH) {
                    this.lane = newLane;
                    this.targetX = (this.lane + 1.5) * TILE_SIZE;
                }
            }
        }

        class Path {
            constructor() {
                this.tiles = []; this.activeLanes = GRID_WIDTH; this.offset = 0; this.shrinkInterval = 500;
                this.nextShrinkScore = this.shrinkInterval; this.createGrid();
                this.isWarning = false;
                this.warningTimer = 0;
            }
            createGrid() { for (let y = 0; y < GRID_HEIGHT + 2; y++) { for (let x = 0; x < GRID_WIDTH; x++) { this.tiles.push({x, y}); } } }
            update() {
                this.offset = (this.offset + gameSpeed) % TILE_SIZE;
                if (score >= this.nextShrinkScore && this.activeLanes > 3 && !this.isWarning) { 
                     this.nextShrinkScore += this.shrinkInterval; 
                     this.shrink();
                }

                if (this.isWarning) {
                    this.warningTimer--;
                    if (this.warningTimer <= 0) {
                        this.isWarning = false;
                        if (this.activeLanes > 3) {
                            this.activeLanes -= 2;
                        }
                    }
                }
            }
            draw() {
                const startLane = Math.floor((GRID_WIDTH - this.activeLanes) / 2); const endLane = startLane + this.activeLanes;
                ctx.strokeStyle = '#3a2fb0'; ctx.lineWidth = 2; ctx.shadowColor = '#3a2fb0'; ctx.shadowBlur = 10;
                this.tiles.forEach(tile => { 
                    if (this.isWarning) {
                        const isWarnedLane = tile.x === startLane || tile.x === endLane - 1;
                        if (isWarnedLane && Math.floor(this.warningTimer / 10) % 2 === 0) {
                            return;
                        }
                    }
                    if (tile.x >= startLane && tile.x < endLane) {
                        const tileY = tile.y * TILE_SIZE - this.offset; const tileX = (tile.x + 1) * TILE_SIZE;
                        ctx.strokeRect(tileX, tileY, TILE_SIZE, TILE_SIZE); 
                    } 
                });
            }
            shrink() { 
                this.isWarning = true;
                this.warningTimer = 300; 
            }
            isLaneActive(lane) { const startLane = Math.floor((GRID_WIDTH - this.activeLanes) / 2); return lane >= startLane && lane < startLane + this.activeLanes; }
        }

        class Pulse {
            constructor(lane, speed) { this.lane = lane; this.x = (this.lane + 1.5) * TILE_SIZE; this.y = -PULSE_HEIGHT; this.speed = speed; this.color = '#ff00ff'; }
            update() { this.y += this.speed; }
            draw() {
                ctx.save(); ctx.fillStyle = this.color; ctx.shadowColor = this.color; ctx.shadowBlur = 15;
                ctx.fillRect(this.x - TILE_SIZE/2, this.y - PULSE_HEIGHT/2, TILE_SIZE, PULSE_HEIGHT);
                ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; ctx.beginPath();
                ctx.moveTo(this.x - TILE_SIZE/2, this.y + (Math.random() - 0.5) * PULSE_HEIGHT);
                ctx.lineTo(this.x + TILE_SIZE/2, this.y + (Math.random() - 0.5) * PULSE_HEIGHT);
                ctx.stroke(); ctx.restore();
            }
        }

        class PowerUp {
            constructor(lane, type) {
                this.lane = lane;
                this.x = (this.lane + 1.5) * TILE_SIZE;
                this.y = -TILE_SIZE;
                this.type = type;
                this.size = PLAYER_SIZE * 1.2;
                this.rotation = 0;
                this.colors = { shield: '#00aaff', score_boost: '#ffd700', clear: '#00ff7f' };
                this.color = this.colors[type];
            }
            update() { this.y += gameSpeed * 0.8; this.rotation += 0.05; }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
                ctx.fillStyle = this.color; ctx.shadowColor = this.color; ctx.shadowBlur = 20;
                ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill(); ctx.restore();
            }
        }
        
        class Particle {
            constructor(x, y, radius, color, velocity, life) { this.x = x; this.y = y; this.radius = radius; this.color = color; this.velocity = velocity; this.life = life; this.initialLife = life; }
            draw() { ctx.save(); ctx.globalAlpha = this.life / this.initialLife; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
            update() { this.x += this.velocity.x; this.y += this.velocity.y; this.life--; }
        }
        
        class Star {
            constructor(layer) {
                this.x = Math.random() * canvas.width; this.y = Math.random() * canvas.height;
                this.layer = layer; this.size = (Math.random() * 0.5 + 0.5) * layer; this.speed = (Math.random() * 0.2 + 0.1) * layer;
            }
            draw() { ctx.fillStyle = `rgba(255, 255, 255, ${this.size * 0.3})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); }
            update() {
                if (gameState === 'playing' || gameState === 'menu') {
                    const currentSpeed = (gameState === 'playing') ? gameSpeed : 1;
                    this.y += currentSpeed * this.speed * 0.2;
                }
                if (this.y > canvas.height) { this.y = 0; this.x = Math.random() * canvas.width; }
            }
        }

        // --- Game Logic ---
        function init() {
            setCanvasDimensions(); score = 0; frameCount = 0; gameSpeed = 5;
            player = new Player(); path = new Path();
            pulses = []; particles = []; powerups = [];
            shieldActive = false; scoreBoostActive = false;
            scoreBoostTimer = 0;
            scoreEl.textContent = 0;
            scoreContainer.classList.remove('hidden');
            menu.classList.add('hidden');
            gameState = 'playing';
        }

        function update() {
            stars.forEach(star => star.update());
            particles = particles.filter(p => p.life > 0);
            particles.forEach(p => p.update());
            if (gameState !== 'playing') return;
            frameCount++; score += scoreBoostActive ? 2 : 1; scoreEl.textContent = score;
            if (frameCount % 300 === 0) gameSpeed = Math.min(15, gameSpeed + 0.5);
            path.update(); player.update();
            if (frameCount % Math.max(15, 60 - Math.floor(score / 100)) === 0) { spawnEntities(); }
            pulses = pulses.filter(p => p.y <= canvas.height); pulses.forEach(pulse => pulse.update());
            powerups = powerups.filter(p => p.y <= canvas.height); powerups.forEach(p => p.update());
            updatePowerUps(); checkCollisions();
        }

        function spawnEntities() {
            const startLane = Math.floor((GRID_WIDTH - path.activeLanes) / 2);
            const availableLanes = Array.from({ length: path.activeLanes }, (_, i) => startLane + i);
            if (availableLanes.length === 0) return;
            if (Math.random() < 0.12 && !shieldActive && !scoreBoostActive) {
                const lane = availableLanes[Math.floor(Math.random() * availableLanes.length)];
                const types = ['shield', 'score_boost', 'clear'];
                const type = types[Math.floor(Math.random() * types.length)];
                powerups.push(new PowerUp(lane, type)); return;
            }
            const patternType = Math.random();
            if (patternType < 0.7 || availableLanes.length < 3) {
                const lane = availableLanes[Math.floor(Math.random() * availableLanes.length)];
                pulses.push(new Pulse(lane, gameSpeed));
            } else {
                const firstLaneIndex = Math.floor(Math.random() * (availableLanes.length - 2));
                const lane1 = availableLanes[firstLaneIndex];
                const lane2 = availableLanes[firstLaneIndex + 2]; 
                pulses.push(new Pulse(lane1, gameSpeed)); pulses.push(new Pulse(lane2, gameSpeed));
            }
        }

        function updatePowerUps() {
            if (scoreBoostActive) { scoreBoostTimer--; if (scoreBoostTimer <= 0) scoreBoostActive = false; }
            updatePowerUpUI();
        }

        function updatePowerUpUI() {
            powerupStatusEl.innerHTML = '';
            if (shieldActive) powerupStatusEl.innerHTML += `<div class="powerup-icon bg-blue-500 rounded-full p-1 shadow-lg">üõ°Ô∏è</div>`;
            if (scoreBoostActive) powerupStatusEl.innerHTML += `<div class="powerup-icon bg-yellow-500 rounded-full p-1 shadow-lg">üí∞</div>`;
        }

        function checkCollisions() {
            for (let i = pulses.length - 1; i >= 0; i--) {
                const pulse = pulses[i]; const collisionDistance = PLAYER_SIZE * 0.8 + PULSE_HEIGHT / 2;
                if (pulse.lane === player.lane && Math.abs(pulse.y - player.y) < collisionDistance) {
                    if (shieldActive) {
                        shieldActive = false; pulses.splice(i, 1); 
                        for (let j = 0; j < 40; j++) { const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 4 + 1; particles.push(new Particle(player.currentX, player.y, 2, '#00aaff', { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed }, 35)); }
                        screenShakeIntensity = 12;
                    } else { gameOver(); break; }
                }
            }
            if (player && !path.isLaneActive(player.lane)) {
                if(shieldActive) {
                    shieldActive = false;
                    for (let j = 0; j < 40; j++) { const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 4 + 1; particles.push(new Particle(player.currentX, player.y, 2, '#00aaff', { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed }, 35)); }
                    screenShakeIntensity = 12;
                } else { gameOver(); }
            }
            powerups.forEach((powerup, index) => {
                 const dist = Math.hypot(powerup.x - player.currentX, powerup.y - player.y);
                 if (dist < powerup.size + PLAYER_SIZE) { activatePowerUp(powerup.type); powerups.splice(index, 1); }
            });
        }
        
        function activatePowerUp(type) {
             for (let i = 0; i < 30; i++) { const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 4 + 1; particles.push(new Particle(player.currentX, player.y, 2, '#fff', { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed }, 30)); }
            screenShakeIntensity = 10;
            if (type === 'shield') shieldActive = true; 
            if (type === 'score_boost') { scoreBoostActive = true; scoreBoostTimer = POWERUP_DURATION; }
            if (type === 'clear') pulses = []; 
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            if (screenShakeIntensity > 0) { const dx = (Math.random() - 0.5) * screenShakeIntensity; const dy = (Math.random() - 0.5) * screenShakeIntensity; ctx.translate(dx, dy); screenShakeIntensity *= 0.9; }
            stars.forEach(star => star.draw());
            if (path) path.draw();
            pulses.forEach(pulse => pulse.draw()); powerups.forEach(p => p.draw()); particles.forEach(p => p.draw());
            if ((gameState === 'playing' || gameState === 'gameOver') && player) player.draw();
            ctx.restore();
        }

        function gameOver() {
            if (gameState === 'gameOver') return; 
            gameState = 'gameOver';
            
            if (score > highScore) { highScore = score; localStorage.setItem('voltDodgeHighScore', highScore); highScoreEl.textContent = highScore; }
            
            // Robustly update total distance
            let savedTotalDistance = parseInt(localStorage.getItem('voltDodgeTotalDistance'));
            if (isNaN(savedTotalDistance)) {
                savedTotalDistance = 0;
            }
            totalDistance = savedTotalDistance + score;
            localStorage.setItem('voltDodgeTotalDistance', totalDistance);
            
            if (score < previousScore && previousScore > 100) {
                const taunts = [
                    `Aww, only ${score}? Looks like you need to work on your reflexes.`,
                    `Just ${score}? My grandmother dodges better, and she's asleep.`,
                    `${score} is cute. Your previous score of ${previousScore} is laughing, though.`,
                    `Are you even trying? ${score} won't impress anyone.`
                ];
                tauntMessageEl.textContent = taunts[Math.floor(Math.random() * taunts.length)];
                tauntMessageEl.classList.remove('hidden');
            } else {
                tauntMessageEl.classList.add('hidden');
            }
            previousScore = score;
            localStorage.setItem('voltDodgePreviousScore', previousScore);

            for (let i = 0; i < 50; i++) { const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 5 + 1; particles.push(new Particle(player.currentX, player.y, 3, '#ff00ff', { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed }, 40)); }
            screenShakeIntensity = 15;
            
            setTimeout(() => {
                scoreContainer.classList.add('hidden'); menu.classList.remove('hidden');
                startMenu.classList.add('hidden'); gameOverMenu.classList.remove('hidden');
                finalScoreEl.textContent = score;
            }, 500);
        }

        function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }

        function openSkinsMenu(fromMenu) {
            menuToReturnTo = fromMenu;
            startMenu.classList.add('hidden');
            gameOverMenu.classList.add('hidden');
            skinsMenu.classList.remove('hidden');
            totalDistanceEl.textContent = totalDistance;
            populateSkinsMenu();
        }

        function closeSkinsMenu() {
            skinsMenu.classList.add('hidden');
            if (menuToReturnTo === 'start') {
                startMenu.classList.remove('hidden');
            } else {
                gameOverMenu.classList.remove('hidden');
            }
        }

        function populateSkinsMenu() {
            skinsGrid.innerHTML = '';
            SKINS.forEach(skin => {
                const isUnlocked = totalDistance >= skin.unlockScore;
                const isSelected = skin.id === currentSkinId;
                
                const card = document.createElement('div');
                card.className = `skin-card p-4 rounded-lg flex flex-col items-center justify-between ${isSelected ? 'selected' : ''} ${!isUnlocked ? 'locked' : ''}`;
                
                const unlockText = isUnlocked ? 'Unlocked' : `Unlock at ${skin.unlockScore}`;
                card.innerHTML = `
                    <div class="text-xl font-bold">${skin.name}</div>
                    <div class="w-16 h-16 my-4 bg-gray-800 rounded-full flex items-center justify-center text-3xl" style="color:${skin.color}; box-shadow: 0 0 10px ${skin.color};">
                        ${skin.symbol}
                    </div>
                    <div class="text-sm">${unlockText}</div>
                    <div class="mt-2 flex space-x-2 w-full">
                        <button class="select-skin-btn neon-button py-1 rounded-md text-sm flex-1" data-skin-id="${skin.id}" ${!isUnlocked ? 'disabled' : ''}>
                            ${isSelected ? 'Selected' : 'Select'}
                        </button>
                        <button class="play-with-skin-btn neon-button active py-1 rounded-md text-sm flex-1" data-skin-id="${skin.id}" ${!isUnlocked ? 'disabled' : ''}>
                            Play
                        </button>
                    </div>
                `;
                skinsGrid.appendChild(card);
            });
        }
        
        function handleSkinSelection(e) {
            const target = e.target;
            if (target.classList.contains('select-skin-btn')) {
                const skinId = target.dataset.skinId;
                if (skinId) {
                    currentSkinId = skinId;
                    localStorage.setItem('voltDodgeCurrentSkin', skinId);
                    populateSkinsMenu();
                }
            } else if (target.classList.contains('play-with-skin-btn')) {
                const skinId = target.dataset.skinId;
                if(skinId) {
                    currentSkinId = skinId;
                    localStorage.setItem('voltDodgeCurrentSkin', skinId);
                    init();
                }
            }
        }

        // --- Event Listeners ---
        function handleKeyDown(e) { if (gameState !== 'playing') return; if (e.key === 'ArrowLeft' || e.key === 'a') player.move(-1); else if (e.key === 'ArrowRight' || e.key === 'd') player.move(1); }
        function handleTouchStart(e) { touchStartX = e.touches[0].clientX; }
        function handleTouchMove(e) { touchEndX = e.touches[0].clientX; }
        function handleTouchEnd() {
            if (gameState !== 'playing' || touchStartX === 0) return;
            const swipeDistance = touchEndX - touchStartX;
            if (Math.abs(swipeDistance) > 30) { if (swipeDistance < 0) player.move(-1); else player.move(1); }
            touchStartX = 0; touchEndX = 0;
        }
        
        window.addEventListener('keydown', handleKeyDown);
        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', handleTouchEnd);
        startButton.addEventListener('click', init);
        retryButton.addEventListener('click', init);
        skinsButton.addEventListener('click', () => openSkinsMenu('start'));
        skinsButtonGameOver.addEventListener('click', () => openSkinsMenu('gameOver'));
        backButton.addEventListener('click', closeSkinsMenu);
        skinsGrid.addEventListener('click', handleSkinSelection);
        window.addEventListener('resize', setCanvasDimensions);
        
        // --- Final Setup ---
        function loadGame() {
            const savedHighScore = parseInt(localStorage.getItem('voltDodgeHighScore'));
            const savedTotalDistance = parseInt(localStorage.getItem('voltDodgeTotalDistance'));
            const savedPreviousScore = parseInt(localStorage.getItem('voltDodgePreviousScore'));

            highScore = isNaN(savedHighScore) ? 0 : savedHighScore;
            totalDistance = isNaN(savedTotalDistance) ? 0 : savedTotalDistance;
            previousScore = isNaN(savedPreviousScore) ? 0 : savedPreviousScore;
            
            currentSkinId = localStorage.getItem('voltDodgeCurrentSkin') || 'default';
            highScoreEl.textContent = highScore;
            
            setCanvasDimensions();
            if (stars.length === 0) {
                 for (let i = 0; i < 150; i++) stars.push(new Star(Math.ceil(Math.random() * 3)));
            }
            gameLoop();
        }

        loadGame();
    </script>
</body>
</html>
